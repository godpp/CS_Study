# # 자료구조

## # 기본 정렬

* 선택 정렬(Selection Sort)
	* 정의
		* 현재 위치에 들어갈 값을 찾아 정렬하는 배열
		* 현재 위치에 저장 될 값의 크기가 작냐, 크냐에 따라 최소 선택 정렬(Min-Selection Sort)와 최대 선택 정렬(Max-Selection Sort)로 구분 할 수 있다.
		* 최소 선택 정렬은 오름차순, 최대 선택 정력은 내림차순
	* 기본 로직
		1. 정렬 되지 않은 인덱스의 맨 앞에서 부터, 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾아간다.(초기입력에선 배열의 시작위치)
		2. 가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.
		3. 다음 인덱스에서 위 과정을 반복해준다.
	* 시간 복잡도
		* 선택 정렬 알고리즘은 n-1개, n-2개...씩 비교를 반복한다.
		* 배열이 어떻게 되어있던지간에 전체 비교를 진행하므로 시간복잡도는 O(n^2)

```
vector<int> selectionSort(vector<int> arr){
    int i, j;
    
    for (i=0; i<arr.size()-1; i++) {
        int temp = i;
        for (j=i+1; j<arr.size(); j++) {
            if(arr[temp]>=arr[j]){
                temp = j;
            }
        }
        swap(arr[i], arr[temp]);
    }
    return arr;
}
```

* 삽입 정렬(Insertion Sort)
	* 정의
		* 현재 위치에서 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘
	* 기본 로직
		1. 삽입 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스 -1로 잡는다.
		2. 별도로 저장해 둔 삽입을 위한 변수와 비교 인덱스의 배열 값을 비교한다.
		3. 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고, 비교 인덱스를 -1하여 비교를 반복한다.
		4. 만약 삽입 변수가 더 크면, 비교 인덱스 +1에 삽입 변수를 저장한다.
	* 시간 복잡도
		* 최악의 경우(역으로 정렬되어있을 경우)엔 n-1개,n-2개...씩 비교를 반복하여 시간복잡도는 O(n^2)
		* 이미 정렬되어 있는 경우엔 한번씩 밖에 비교를 하지 않아 시간복잡도는 O(n)

```
vector<int> insertionSort(vector<int> arr){
    int i,j;
    
    for (i=1; i<arr.size(); i++) {
        int temp = arr[i];
        j = i-1;
        while (j>=0 && temp < arr[j]) {
            swap(arr[j], arr[j+1]);
            j--;
        }
        arr[j+1] = temp;
    }
    return arr;
}
```

* 버블 정렬(Bubble Sort)
	* 정의
		* 매번 연속된 두 개 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법
		* 오름차순으로 정렬하고자 할 경우, 비교 시마다 큰 값이 뒤로 이동하며, 1바퀴 돌 시 가장 큰 값이 맨 뒤에 저장된다.
		* 맨 마지막에는 비교하는 수들 중 가장 큰 값이 저장 되기 때문에 (전체 배열의 크기 - 현재까지 순환한 바퀴수) 만큼만 반복해 주면 된다.
	* 기본 로직
		1. 버블 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스 값과 바로 이전의 인덱스 값을 비교한다.
		2. 만약 이전 인덱스가 더 크면, 현재 인덱스와 바꿔준다.
		3. 현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교한다.
		4. 이를 (전체 배열의 크기 - 현재까지 순환한 바퀴 수)만큼 반복한다.
	* 시간 복잡도
		* 1부터 비교를 시작하여 n-1개, n-2개...씩 비교를 반복하며, 선택 정렬과 같이 배열이 어떻게 되어있던지 간에 전체 비교를 진행하므로 시간복잡도는 O(n^2)

```
vector<int> bubbleSort(vector<int> arr){
    int i, j;
    
    for (i=0; i<arr.size()-1; i++) {
        for (j=1; j<arr.size()-i; j++) {
            if (arr[j-1] > arr[j]) {
                swap(arr[j-1], arr[j]);
            }
        }
    }
    return arr;
}
```

* 합병 정렬(Merge Sort)
	* 정의
		* 분할 정복 방식으로 설계된 알고리즘이다.
		* 분할 정복은 큰 문제를 반으로 쪼개 문제를 해결해 나가는 방식으로, 분할은 배열의 크기가 1보다 작거나 같을 때까지 반복한다.
		* 입력으로 하나의 배열을 받고, 연산 중에 두 개의 배열로 계속 쪼개 나간 뒤, 합치면서 정렬해 최후에는 하나의 정렬을 출력한다.
	* 기본 로직
		* 분할 과정
			1. 현재 배열을 반으로 쪼갠다. 배열의 시작 위치와 종료 위치를 입력받아 둘을 더한 후 2를 나눠 그 위치를 기준으로 나눈다.
			2. 이를 쪼갠 배열의 크기가 0이거나 1일때까지 반복한다.
		* 합병 과정
			1. 두 배열 A, B의 크기를 비교한다. 각각의 배열의 현재 인덱스를 i, j로 가정하자.
			2. i에는 A배열의 시작 인덱스를 저장하고, j에는 B배열의 시작 주소를 저장한다.
			3. A[i]와 B[j]를 비교한다. 오름차순의 경우 이중에 작은 값을 새 배열 C에 저장한다. A[i]가 더 컸다면 A[i]의 값을 배열 C에 저장해주고, i의 값을 하나 증가시켜준다.
			4. 이를 i나 j 둘 중 하나가 각자 배열의 끝에 도달할 때까지 반복한다.
			5. 끝까지 저장을 못한 배열의 값을 순서대로 전부 다 C에 저장한다.
			6. C 배열을 원래의 배열에 저장해준다.
	* 시간 복잡도
		* 분할 과정
			* 크기가 N인 배열을 분할할때, 한번 분할하면 N/2, N/2 2개, 그 다음 분할하면 N/4,N/4,N/4,N/4 4개이므로 분할 과정은 매번 반씩 감소한다.
			* 즉, logN만큼 반복해야 크기가 1인 배열로 분할 할 수 있다.
		* 합병 과정
			* 두 배열 A, B를 정렬하기 때문에, A배열의 크기를 N1, B배열의 크기를 N2라고 할 경우 O(n1+n2)와 같다.
			* 배열 A와 배열 B는 하나의 배열을 나눈 배열들이기 때문에 전체 배열의 길이가 N이라고 할 경우 N=N1+N2이므로 O(N)이라고 할 수 있다.
		* 각 분할별로 합병을 진행하므로, 합병 정렬의 시간복잡도는 O(NlogN).
```
공부중
```

* 퀵 정렬(Quick Sort)
	* 정의
		* 퀵 정렬 또한 분할 정복을 이용하여 정렬을 수행하는 알고리즘이다.
		* Pivot Point라는 기준이 되는 값을 하나 설정 하는데, 이 값을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮기는 방식으로 정렬을 진행한다.
		* 이를 반복하여 분할된 배열의 크기가 1이되면 배열이 모두 정렬 된 것이다.
	* 기본 로직
		1. Pivot Point로 잡을 배열의 값 하나를 정한다. 보통 맨 앞이나 맨 뒤, 혹은 전체 배열 값 중 중간값이나 랜덤 값으로 정한다.
		2. 분할을 진행하기에 앞서, 비교를 진행하기 위해 가장 왼쪽 배열의 인덱스를 저장하는 left 변수, 가장 오른쪽 배열의 인덱스를 저장한 right 변수를 생성한다.
		3. right부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복하며, 비교한 배열값이 Pivot Point보다 크면 right를 하나 감소시키고 비교를 반복한다. Pivot Point보다 작은 배열 값을 찾으면, 반복을 중지한다.
		4. 그 다음 left부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복하며, 비교한 배열값이 Pivot Point보다 작으면 left를 하나 증가시키고 비교를 반복한다. Pivot Point보다 큰 배열 값을 찾으면, 반복을 중지한다.
		5. left 인덱스의 값과 right 인덱스의 값을 바꿔준다.
		6. 3,4,5 과정을 left < right가 만족 할 때까지 반복한다.
		7. 위 과정이 끝나면 left의 값과 Pivot Point를 바꿔준다.
		8. 맨 왼쪽부터 left-1까지, left+1부터 맨 오른쪽까지로 나눠 퀵 정렬을 반복한다.
	* 시간 복잡도
		* 퀵 정렬은 분할과 동시에 정렬을 진행하는 알고리즘이다.
		* 각 정렬은 배열의 크기 N만큼 비교하며, 이를 총 분할 깊이인 logN만큼 진행하므로 총 비교횟수는 NlogN이다. 즉, 시간 복잡도는 O(NlogN)
		* 이미 배열이 정렬되어있는 경우는 최악의 경우로 분할이 N만큼 일어나므로 시간 복잡도는 O(N^2)
		* 일반적으로 퀵 정렬이 합병 정렬보다 20%이상 빠르다.

```
공부중
```


## # Array

* 정의
	* 동일한 특성을 가지며 일정한 규칙에 따라 몇몇 요소가 나열되어 있는 데이터 집합

* 특징
	* 논리적 저장 순서와 물리적 저장 순서가 일치
	* 인덱스(index)로 해당 원소에 접근할 수 있다.
	* Random Access 가능
	* 삭제 또는 삽입 과정에서 배열의 연속적인 특징이 깨짐으로써 빈 공간이 생긴다.

* 시간 복잡도
	* 원소의 index를 알고 있으면 O(1)로 해당 원소 접근 가능
	* 큰 인덱스를 갖는 원소들은 Shift를 해줘야 하는 비용이 발생해 시간 복잡도는 O(n)


## # LinkedList

* 정의
	* 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조

* 특징
	* 각각의 원소들은 자기 자신 다음이 어떤 원소인지만을 기억하고 있다.
	* 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search하는 과정에 있어서 첫번째 원소부터 다 확인해봐야 한다.
	* 이는 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다.

* 시간 복잡도
	* 연결리스트는 늘어선 노드의 중간지점에서도 자료의 추가와 삭제가 O(1)의 시간에 가능하다는 장점을 갖는다.
	* 그러나 배열이나 트리 구조와는 달리 특정 위치의 데이터를 검색해 내는데에는 O(n)의 시간이 걸리는 단점도 갖고 있다.


## # Stack

* 정의
	* 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형구조

* 특징
	* 나중에 들어간 원소가 먼저 나오는 LIFO(Last In First Out) 구조
	* 자료를 넣는 것 (push)
	* 자료를 꺼내는 것 (pop)


## # Queue

* 정의
	* 먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out)구조로 저장하는 형식

* 종류
	* 선형 큐
		* 막대 모양으로 된 큐
		* 크기가 제한되어 있고 빈 공간을 사용하려면 모든 자료를 꺼내거나 자료를 한 칸씩 옮겨야 한다는 단점이 있다.
	* 원형 큐
		* 선형 큐의 문제점을 보완한 것이 원형 큐이다.
		* front가 큐의 끝에 닿으면 큐의 맨 앞으로 자료를 보내여 원형으로 연결하는 방식
	* 링크드 큐
		* 연결 리스트로 구현한 큐는 큐의 길이를 쉽게 늘릴 수 있어 오버플로우가 발생하지 않는 것이 특징
		* 삽입과 삭제가 제한되지 않아 편리하다.


## # Tree

* 정의
	* 그래프의 일종으로 여러 노드가 한 노드를 가리킬 수 없는 구조

* Binary Tree(이진 트리)
	* 정의
		* 루트 노드가 있는 구조에서 어떤 노드의 자식의 수가 최대 2개를 넘지 않는 트리
	* 종류
		* 포화 이진 트리 - 모든 레벨이 꽉 찬 이진 트리
		* 완전 이진 트리 - 왼쪽에서 오른쪽으로 순서대로 채워진 이진 트리

* Binary Search Tree(이진 탐색 트리)
	* 정의
		* 자료의 탐색이 효율적으로 되는 이진 트리로 저장하는 데이터의 크기에 따라 노드의 위치가 정해진 것
	* 특징
		* 노드의 저장된 키는 유일하다.
		* 루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떠한 노드의 키보다 크다.
		* 루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떠한 노드의 키보다 작다.
	* 순회
		* 중위 순회(Inorder) : 왼쪽 노드 - 루트 노드 - 오른쪽 노드
		* 후위 순회(Postorder) : 왼쪽 노드 - 오른쪽 노드- 루트 노드
		* 전위 순회(Preorder) : 루트 노드 - 왼쪽 노드 - 오른쪽 노드
	* 시간 복잡도
		* 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우(편향 트리)가 발생하기 때문에 최악의 경우는 O(n)
		* 탐색 연산은 O(logN), 트리의 높이를 하나씩 더해 갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문에 정확히 말하면 O(h)

* Heap
	* 정의
		* Tree 중에서도 배열에 기반한 완전 이진 트리
	* 특징
		* 배열에 트리의 값들을 넣어줄 때, 0번째는 건너뛰고 1번 index부터 루트노드가 시작된다.(노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함)
	* 종류
		* 최대힙(Max Heap)
			* 각 노드의 값이 해당 자식들의 값보다 크거나 같은 완전 이진 트리
			* 루트 노드의 값이 제일 크다.
		* 최소힙(Min Heap)
			* 각 노드의 값이 해당 자식들의 값보다 작거나 같은 완전 이진 트리
			* 루트 노드의 값이 제일 작다.
	* 시간 복잡도
		* Heap 구조를 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하기 때문에 Heap에서는 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 Heapify 과정을 거쳐 Heap 구조를 유지
		* 이런 경우에는 결국 O(log N)으로 최대값 또는 최소값 접근 가능

* B-Tree
	* 정의
		* 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조
		* 모든 리프노드들은 같은 높이에 있어야 한다.
		* 모든 노드들은 키와 자식노드에 대한 포인터로 이루어져 있다.
	* 특징
		* 노드의 삽입/삭제 후에도 균형 트리 유지로 균등한 응답 속도를 보장한다.
		* 이 균형 트리 유지를 위해 복잡한 연산 수행이 필요하다.
	* 시간 복잡도
		* O(log N)


## # HashTable

* 정의
	* 해시 함수와 함께 데이터 검색을 효율적으로 하기 위해 사용되는 데이터 구조
	* Key와 Value가 한 쌍을 이루는 데이터를 저장한다.
* 기본 로직
	* HashFuction(key) -> HashCode(배열의 길이로 나머지 연산) -> Index값 접근 -> Value
* 시간 복잡도
	* 특정한 Value를 찾는데 데이터 고유의 인덱스로 접근하게 되므로 O(1)
	* HashTable의 검색 성능은 해쉬 함수의 성능과 HashTable의 크기에 좌우되므로, 충돌이 발생하면 할수록 성능은 O(n)에 가까워진다.
* 충돌(Collision)
	* 경우
		* Key 값은 가짓수가 무한하지만 Hashcode는 정수개 만큼 밖에 제공되지 않아 중복되는 해시코드를 가짐
		* Hashcode는 다르지만 같은 Index에 저장되는 경우
	* 해결법
		* Open Address(개방주소법) : Collision이 발생하면 다른 해시 버킷에 해당 자료를 삽입하는 방식
			* Linear Probing - 순차적으로 탐색하여 비어있는 버킷에 삽입
			* Quadratic Probing - 2차 함수를 이용해 탐색할 위치를 찾아 삽입
			* Double Hashing Probing - 하나의 해시함수에서 충돌이 발생하면 2차 해쉬 함수로 새로운 주소를 할당
		* Separate Chaining(분리연결법)
			* LinkedList : 데이터 개수가 적을 때 사용, 삭제 삽입이 간단, 작은 데이터들을 저장할 때 오버헤드 발생
			* Red-Black Tree : 데이터 개수가 많을 때 사용, 탐색이 빠름, 메모리를 많이 사용
