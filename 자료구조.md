# # 자료구조

## # 기본 정렬

* 선택 정렬(Selection Sort)
	* 정의
		* 현재 위치에 들어갈 값을 찾아 정렬하는 배열
		* 현재 위치에 저장 될 값의 크기가 작냐, 크냐에 따라 최소 선택 정렬(Min-Selection Sort)와 최대 선택 정렬(Max-Selection Sort)로 구분 할 수 있다.
		* 최소 선택 정렬은 오름차순, 최대 선택 정력은 내림차순
	* 기본 로직
		1. 정렬 되지 않은 인덱스의 맨 앞에서 부터, 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾아간다.(초기입력에선 배열의 시작위치)
		2. 가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.
		3. 다음 인덱스에서 위 과정을 반복해준다.
	* 시간 복잡도
		* 선택 정렬 알고리즘은 n-1개, n-2개...씩 비교를 반복한다.
		* 배열이 어떻게 되어있던지간에 전체 비교를 진행하므로 시간복잡도는 O(n^2)

```
vector<int> selectionSort(vector<int> arr){
    int i, j;
    
    for (i=0; i<arr.size()-1; i++) {
        int temp = i;
        for (j=i+1; j<arr.size(); j++) {
            if(arr[temp]>=arr[j]){
                temp = j;
            }
        }
        swap(arr[i], arr[temp]);
    }
    return arr;
}
```

* 삽입 정렬(Insertion Sort)
	* 정의
		* 현재 위치에서 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘
	* 기본 로직
		1. 삽입 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스 -1로 잡는다.
		2. 별도로 저장해 둔 삽입을 위한 변수와 비교 인덱스의 배열 값을 비교한다.
		3. 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고, 비교 인덱스를 -1하여 비교를 반복한다.
		4. 만약 삽입 변수가 더 크면, 비교 인덱스 +1에 삽입 변수를 저장한다.
	* 시간 복잡도
		* 최악의 경우(역으로 정렬되어있을 경우)엔 n-1개,n-2개...씩 비교를 반복하여 시간복잡도는 O(n^2)
		* 이미 정렬되어 있는 경우엔 한번씩 밖에 비교를 하지 않아 시간복잡도는 O(n)

```
vector<int> insertionSort(vector<int> arr){
    int i,j;
    
    for (i=1; i<arr.size(); i++) {
        int temp = arr[i];
        j = i-1;
        while (j>=0 && temp < arr[j]) {
            swap(arr[j], arr[j+1]);
            j--;
        }
        arr[j+1] = temp;
    }
    return arr;
}
```

* 버블 정렬(Bubble Sort)
	* 정의
		* 매번 연속된 두 개 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법
		* 오름차순으로 정렬하고자 할 경우, 비교 시마다 큰 값이 뒤로 이동하며, 1바퀴 돌 시 가장 큰 값이 맨 뒤에 저장된다.
		* 맨 마지막에는 비교하는 수들 중 가장 큰 값이 저장 되기 때문에 (전체 배열의 크기 - 현재까지 순환한 바퀴수) 만큼만 반복해 주면 된다.
	* 기본 로직
		1. 버블 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스 값과 바로 이전의 인덱스 값을 비교한다.
		2. 만약 이전 인덱스가 더 크면, 현재 인덱스와 바꿔준다.
		3. 현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교한다.
		4. 이를 (전체 배열의 크기 - 현재까지 순환한 바퀴 수)만큼 반복한다.
	* 시간 복잡도
		* 1부터 비교를 시작하여 n-1개, n-2개...씩 비교를 반복하며, 선택 정렬과 같이 배열이 어떻게 되어있던지 간에 전체 비교를 진행하므로 시간복잡도는 O(n^2)

```
vector<int> bubbleSort(vector<int> arr){
    int i, j;
    
    for (i=0; i<arr.size()-1; i++) {
        for (j=1; j<arr.size()-i; j++) {
            if (arr[j-1] > arr[j]) {
                swap(arr[j-1], arr[j]);
            }
        }
    }
    return arr;
}
```