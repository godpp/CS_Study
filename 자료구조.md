# # 자료구조

## # 기본 정렬

* 선택 정렬(Selection Sort)
	* 정의
		* 현재 위치에 들어갈 값을 찾아 정렬하는 배열
		* 현재 위치에 저장 될 값의 크기가 작냐, 크냐에 따라 최소 선택 정렬(Min-Selection Sort)와 최대 선택 정렬(Max-Selection Sort)로 구분 할 수 있다.
		* 최소 선택 정렬은 오름차순, 최대 선택 정력은 내림차순
	* 기본 로직
		1. 정렬 되지 않은 인덱스의 맨 앞에서 부터, 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾아간다.(초기입력에선 배열의 시작위치)
		2. 가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.
		3. 다음 인덱스에서 위 과정을 반복해준다.
	* 시간 복잡도
		* 선택 정렬 알고리즘은 n-1개, n-2개...씩 비교를 반복한다.
		* 배열이 어떻게 되어있던지간에 전체 비교를 진행하므로 시간복잡도는 O(n^2)

```
vector<int> selectionSort(vector<int> arr){
    int i, j;
    
    for (i=0; i<arr.size()-1; i++) {
        int temp = i;
        for (j=i+1; j<arr.size(); j++) {
            if(arr[temp]>=arr[j]){
                temp = j;
            }
        }
        swap(arr[i], arr[temp]);
    }
    return arr;
}
```

* 삽입 정렬(Insertion Sort)
	* 정의
		* 현재 위치에서 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘
	* 기본 로직
		1. 삽입 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스 -1로 잡는다.
		2. 별도로 저장해 둔 삽입을 위한 변수와 비교 인덱스의 배열 값을 비교한다.
		3. 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고, 비교 인덱스를 -1하여 비교를 반복한다.
		4. 만약 삽입 변수가 더 크면, 비교 인덱스 +1에 삽입 변수를 저장한다.
	* 시간 복잡도
		* 최악의 경우(역으로 정렬되어있을 경우)엔 n-1개,n-2개...씩 비교를 반복하여 시간복잡도는 O(n^2)
		* 이미 정렬되어 있는 경우엔 한번씩 밖에 비교를 하지 않아 시간복잡도는 O(n)

```
vector<int> insertionSort(vector<int> arr){
    int i,j;
    
    for (i=1; i<arr.size(); i++) {
        int temp = arr[i];
        j = i-1;
        while (j>=0 && temp < arr[j]) {
            swap(arr[j], arr[j+1]);
            j--;
        }
        arr[j+1] = temp;
    }
    return arr;
}
```