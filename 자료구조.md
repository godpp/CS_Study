# # 자료구조

## # 기본 정렬

* 선택 정렬(Selection Sort)
	* 정의
		* 현재 위치에 들어갈 값을 찾아 정렬하는 배열
		* 현재 위치에 저장 될 값의 크기가 작냐, 크냐에 따라 최소 선택 정렬(Min-Selection Sort)와 최대 선택 정렬(Max-Selection Sort)로 구분 할 수 있다.
		* 최소 선택 정렬은 오름차순, 최대 선택 정력은 내림차순
	* 기본 로직
		1. 정렬 되지 않은 인덱스의 맨 앞에서 부터, 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾아간다.(초기입력에선 배열의 시작위치)
		2. 가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.
		3. 다음 인덱스에서 위 과정을 반복해준다.
	* 시간 복잡도
		* 선택 정렬 알고리즘은 n-1개, n-2개...씩 비교를 반복한다.
		* 배열이 어떻게 되어있던지간에 전체 비교를 진행하므로 시간복잡도는 O(n^2)

```
vector<int> selectionSort(vector<int> arr){
    int i, j;
    
    for (i=0; i<arr.size()-1; i++) {
        int temp = i;
        for (j=i+1; j<arr.size(); j++) {
            if(arr[temp]>=arr[j]){
                temp = j;
            }
        }
        swap(arr[i], arr[temp]);
    }
    return arr;
}
```

* 삽입 정렬(Insertion Sort)
	* 정의
		* 현재 위치에서 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘
	* 기본 로직
		1. 삽입 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스 -1로 잡는다.
		2. 별도로 저장해 둔 삽입을 위한 변수와 비교 인덱스의 배열 값을 비교한다.
		3. 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고, 비교 인덱스를 -1하여 비교를 반복한다.
		4. 만약 삽입 변수가 더 크면, 비교 인덱스 +1에 삽입 변수를 저장한다.
	* 시간 복잡도
		* 최악의 경우(역으로 정렬되어있을 경우)엔 n-1개,n-2개...씩 비교를 반복하여 시간복잡도는 O(n^2)
		* 이미 정렬되어 있는 경우엔 한번씩 밖에 비교를 하지 않아 시간복잡도는 O(n)

```
vector<int> insertionSort(vector<int> arr){
    int i,j;
    
    for (i=1; i<arr.size(); i++) {
        int temp = arr[i];
        j = i-1;
        while (j>=0 && temp < arr[j]) {
            swap(arr[j], arr[j+1]);
            j--;
        }
        arr[j+1] = temp;
    }
    return arr;
}
```

* 버블 정렬(Bubble Sort)
	* 정의
		* 매번 연속된 두 개 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법
		* 오름차순으로 정렬하고자 할 경우, 비교 시마다 큰 값이 뒤로 이동하며, 1바퀴 돌 시 가장 큰 값이 맨 뒤에 저장된다.
		* 맨 마지막에는 비교하는 수들 중 가장 큰 값이 저장 되기 때문에 (전체 배열의 크기 - 현재까지 순환한 바퀴수) 만큼만 반복해 주면 된다.
	* 기본 로직
		1. 버블 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스 값과 바로 이전의 인덱스 값을 비교한다.
		2. 만약 이전 인덱스가 더 크면, 현재 인덱스와 바꿔준다.
		3. 현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교한다.
		4. 이를 (전체 배열의 크기 - 현재까지 순환한 바퀴 수)만큼 반복한다.
	* 시간 복잡도
		* 1부터 비교를 시작하여 n-1개, n-2개...씩 비교를 반복하며, 선택 정렬과 같이 배열이 어떻게 되어있던지 간에 전체 비교를 진행하므로 시간복잡도는 O(n^2)

```
vector<int> bubbleSort(vector<int> arr){
    int i, j;
    
    for (i=0; i<arr.size()-1; i++) {
        for (j=1; j<arr.size()-i; j++) {
            if (arr[j-1] > arr[j]) {
                swap(arr[j-1], arr[j]);
            }
        }
    }
    return arr;
}
```

* 합병 정렬(Merge Sort)
	* 정의
		* 분할 정복 방식으로 설계된 알고리즘이다.
		* 분할 정복은 큰 문제를 반으로 쪼개 문제를 해결해 나가는 방식으로, 분할은 배열의 크기가 1보다 작거나 같을 때까지 반복한다.
		* 입력으로 하나의 배열을 받고, 연산 중에 두 개의 배열로 계속 쪼개 나간 뒤, 합치면서 정렬해 최후에는 하나의 정렬을 출력한다.
	* 기본 로직
		* 분할 과정
			1. 현재 배열을 반으로 쪼갠다. 배열의 시작 위치와 종료 위치를 입력받아 둘을 더한 후 2를 나눠 그 위치를 기준으로 나눈다.
			2. 이를 쪼갠 배열의 크기가 0이거나 1일때까지 반복한다.
		* 합병 과정
			1. 두 배열 A, B의 크기를 비교한다. 각각의 배열의 현재 인덱스를 i, j로 가정하자.
			2. i에는 A배열의 시작 인덱스를 저장하고, j에는 B배열의 시작 주소를 저장한다.
			3. A[i]와 B[j]를 비교한다. 오름차순의 경우 이중에 작은 값을 새 배열 C에 저장한다. A[i]가 더 컸다면 A[i]의 값을 배열 C에 저장해주고, i의 값을 하나 증가시켜준다.
			4. 이를 i나 j 둘 중 하나가 각자 배열의 끝에 도달할 때까지 반복한다.
			5. 끝까지 저장을 못한 배열의 값을 순서대로 전부 다 C에 저장한다.
			6. C 배열을 원래의 배열에 저장해준다.
	* 시간 복잡도
		* 분할 과정
			* 크기가 N인 배열을 분할할때, 한번 분할하면 N/2, N/2 2개, 그 다음 분할하면 N/4,N/4,N/4,N/4 4개이므로 분할 과정은 매번 반씩 감소한다.
			* 즉, logN만큼 반복해야 크기가 1인 배열로 분할 할 수 있다.
		* 합병 과정
			* 두 배열 A, B를 정렬하기 때문에, A배열의 크기를 N1, B배열의 크기를 N2라고 할 경우 O(n1+n2)와 같다.
			* 배열 A와 배열 B는 하나의 배열을 나눈 배열들이기 때문에 전체 배열의 길이가 N이라고 할 경우 N=N1+N2이므로 O(N)이라고 할 수 있다.
		* 각 분할별로 합병을 진행하므로, 합병 정렬의 시간복잡도는 O(NlogN).

* 퀵 정렬(Quick Sort)
	* 정의
		* 퀵 정렬 또한 분할 정복을 이용하여 정렬을 수행하는 알고리즘이다.
		* Pivot Point라는 기준이 되는 값을 하나 설정 하는데, 이 값을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮기는 방식으로 정렬을 진행한다.
		* 이를 반복하여 분할된 배열의 크기가 1이되면 배열이 모두 정렬 된 것이다.
	* 기본 로직
		1. Pivot Point로 잡을 배열의 값 하나를 정한다. 보통 맨 앞이나 맨 뒤, 혹은 전체 배열 값 중 중간값이나 랜덤 값으로 정한다.
		2. 분할을 진행하기에 앞서, 비교를 진행하기 위해 가장 왼쪽 배열의 인덱스를 저장하는 left 변수, 가장 오른쪽 배열의 인덱스를 저장한 right 변수를 생성한다.
		3. right부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복하며, 비교한 배열값이 Pivot Point보다 크면 right를 하나 감소시키고 비교를 반복한다. Pivot Point보다 작은 배열 값을 찾으면, 반복을 중지한다.
		4. 그 다음 left부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복하며, 비교한 배열값이 Pivot Point보다 작으면 left를 하나 증가시키고 비교를 반복한다. Pivot Point보다 큰 배열 값을 찾으면, 반복을 중지한다.
		5. left 인덱스의 값과 right 인덱스의 값을 바꿔준다.
		6. 3,4,5 과정을 left < right가 만족 할 때까지 반복한다.
		7. 위 과정이 끝나면 left의 값과 Pivot Point를 바꿔준다.
		8. 맨 왼쪽부터 left-1까지, left+1부터 맨 오른쪽까지로 나눠 퀵 정렬을 반복한다.
	* 시간 복잡도
		* 퀵 정렬은 분할과 동시에 정렬을 진행하는 알고리즘이다.
		* 각 정렬은 배열의 크기 N만큼 비교하며, 이를 총 분할 깊이인 logN만큼 진행하므로 총 비교횟수는 NlogN이다. 즉, 시간 복잡도는 O(NlogN)
		* 이미 배열이 정렬되어있는 경우는 최악의 경우로 분할이 N만큼 일어나므로 시간 복잡도는 O(N^2)
		* 일반적으로 퀵 정렬이 합병 정렬보다 20%이상 빠르다.